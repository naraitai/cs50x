0 to 255
1 byte each colour
3 bytes each pixel

bmp.h - structs etc


functions have 3 arguments height /width / 2d array of triples (image[0][0] is first part of first row)

every pixle is a struct

// Grayscale
Taken an image
Turnit into back and white version

RGB values all same = different shade of gray. Lower darker, higher lighter.
Average of RGB values.
Average value might be decimal. Need to be integer. So don't forget to round.
iterate each row and each elemnt of row.

Average is r + g + b / 3
math.h has round() - double round(double x); make a double, but can cast to an integer.

nested for loop with i being height and j being width
then to access the triple it is image[i][j] that contains an r b g value, so need to access each one in turn.
use type byte to access each byte so each colour individually
tribple structs is b / g / r and names rgbtBlue etc (dot notation) image[i][j].rgbtBlue add them and divide by 3


Sepia
Take image
Turn in sepia version of image

each pixel to sepia equivalent
sepia algorithm (see notes)
need to round to make integer
need to be less than 255
if over cap to 255

algorithm is different for each RGB value
sepiaRed

sepiaRed = .393 * originalRed + .769 * originalGreen + .189 * originalBlue
  sepiaGreen = .349 * originalRed + .686 * originalGreen + .168 * originalBlue
  sepiaBlue = .272 * originalRed + .534 * originalGreen + .131 * originalBlue


// Reflect
Take image
Reflect image horizontally

row stays the same
elements in row swap in row

for every row
  pixel on left swap with pixel on right
  rightmost pixel - leftmost pixel


Blur
take image
box-blurred version of image

average of old colou rvalue in grid around pixel
edge pixels average 6 in one row and one column from original pixel

for each row
  for each pixel of each row
    find the surrounding pixels this row - 1, this row + 1, this row - 1 & this column - 1


average of all red, average of all green and average of all blue.

if corner = 4 pixels
corner is if i and j equals zero

//Corners

// Top left
if  i and j equal 0
  p1 =
  p2
  p3
  p4


// Top right
if i equals 0 and j equal width

// Bottom left
if i equals height and j equals 0

//Bottom right
if i equals height and j equals width



if ij is 0
  then 4



  if j is 0
    corner


if edge = 6

image[][].rgbtRed

ij


corners are opposites of each other

top left can't takeaway
bottomo right can't add

if i is zero or higher









            for (int k = 0; k < 10; k ++)
            {

            }

            if (i >= 0 && j >= 0)
            {
                red += image[i][j + 1].rgbtRed;
                green += image[i][j + 1].rgbtGreen;
                blue += image[i][j + 1].rgbtBlue;
            }






            red += image[i][j].rgbtRed;
            green = image[i][j].rgbtGren;
            blue = image[i][j].rgbtBlue;


            red += image[i - 1][j - 1].rgbtred


            red += image[i - 1][j - 1]
            image[i][j - 1]
            image[i + 1][j - 1]



            if (i > 0 && j < width)


            // Corners

            // Top left
            if (i == 0 && j == 0)
            {
                red = (int)round((image[i][j].rgbtRed + image[i][j + 1].rgbtRed + image[i + 1][j].rgbtRed + image[i + 1][j + 1].rgbtRed) / 4);
                green = (int)round((image[i][j].rgbtGreen + image[i][j + 1].rgbtGreen + image[i + 1][j].rgbtGreen + image[i + 1][j + 1].rgbtGreen) / 4);
                blue = (int)round((image[i][j].rgbtBlue + image[i][j + 1].rgbtBlue + image[i + 1][j].rgbtBlue + image[i + 1][j + 1].rgbtBlue) / 4);
            }

            // Top right
            if (i == 0 && j == width)
            {
                red = (int)round((image[i][j].rgbtRed + image[i][j - 1].rgbtRed + image[i + 1][j].rgbtRed + image[i + 1][j - 1].rgbtRed) / 4);
                green = (int)round((image[i][j].rgbtGreen + image[i][j - 1].rgbtGreen + image[i + 1][j].rgbtGreen + image[i + 1][j - 1].rgbtGreen) / 4);
                blue = (int)round((image[i][j].rgbtBlue + image[i][j - 1].rgbtBlue + image[i + 1][j].rgbtBlue + image[i + 1][j - 1].rgbtBlue) / 4);
            }

            // Bottom left
            if (i == height && j == 0)
            {
                red = (int)round((image[i][j].rgbtRed + image[i][j + 1].rgbtRed + image[i - 1][j].rgbtRed + image[i - 1][j + 1].rgbtRed) / 4);
                green = (int)round((image[i][j].rgbtGreen + image[i][j + 1].rgbtGreen + image[i - 1][j].rgbtGreen + image[i - 1][j + 1].rgbtGreen) / 4);
                blue = (int)round((image[i][j].rgbtBlue + image[i][j + 1].rgbtBlue + image[i - 1][j].rgbtBlue + image[i - 1][j + 1].rgbtBlue) / 4);
            }

            // Bottom right
            if (i == height && j == width)
            {
                red = (int)round((image[i][j].rgbtRed + image[i][j - 1].rgbtRed + image[i - 1][j].rgbtRed + image[i - 1][j - 1].rgbtRed) / 4);
                green = (int)round((image[i][j].rgbtGreen + image[i][j - 1].rgbtGreen + image[i - 1][j].rgbtGreen + image[i - 1][j - 1].rgbtGreen) / 4);
                blue = (int)round((image[i][j].rgbtBlue + image[i][j - 1].rgbtBlue + image[i - 1][j].rgbtBlue + image[i - 1][j - 1].rgbtBlue) / 4);
            }




if row - 1 and column - 1 is zero or more
  add values for column - 1 row - 1 / - 0 / + 1
  add values for column - 0 row - 1 / column + 1 row - 1

if row + 1 and column + 1 is less than or equal to height / width
  add values for column + 1 row + 1 / + 0 /
  
  
  
  
            
            if (i - 1 >= 0 && j - 1 >= 0)
            {
                for (int g = i - 1; g < 1; g++)
                {
                    for (int h = j - 1; h < 1; h++)
                    {
                        red += copy[g][h].rgbt.Red;
                        green += copy[g][h].rgbtGreen;
                        blue += copy[g][h].rgbtBlue;
                        pixel++;
                    }
                }
            }
            
            if (i + 1 <= height && j + i <= width)
            {
                for (int y = i + 1; y < 1; y++)
                {
                    for (int f = j + 1; f < 1; f++)
                    {
                        red += copy[y][f].rgbtRed;
                        green += copy[y][f].rgbtGreen;
                        blue += copy[y][f].rgbtBlue;
                        pixel++;
                    }
                }
            }
            
            if (i - 1 >= 0)
            {
                for (int v = 0; v < 2; v++)
                {
                    red += copy[]
                    green +=
                    blue +=
                    pixel==;
                }
                
            }
            
            

            for (int k = i - 1; count + pixel < 10; k++)
            {
                for( int l = j - 1; pixel < 10; l++)
                {
                    if (k == -1 || l == -1)
                    {
                        count++;
                        break;
                    }
                    else if (k == height + 1 || l == width + 1)
                    {
                        count++;
                        break;
                    }
                    else
                    {
                        red += copy[k][l].rgbtRed;
                        green += copy[k][l].rgbtGreen;
                        blue += copy[k][l].rgbtBlue;
                        pixel++;
                    }
                }
            }

            // Averages
            red = (int)round(red / pixel);
            green = (int)round(green / pixel);
            blue = (int)round(blue / pixel);

            // Change original
            image[i][j].rgbtRed = red;
            image[i][j].rgbtGreen = green;
            image[i][j].rgbtBlue = blue;



 for (int k = i - 1; k < 1; k++)
                {
                    for (int l = j - 1; l <= 0; l++)
                    {
                        red += copy[k][l].rgbtRed;
                        green += copy[k][l].rgbtGreen;
                        blue += copy[k][l].rgbtBlue;
                        pixel++;
                    }
                }
            }
            
            if (i + 1 <= height && j + 1 <= width)
            {
                for (int k = i + 1; k < 1; k++)
                {
                    for (int l = j + 1; l <= 0; l++)
                    {
                        red += copy[k][l].rgbtRed;
                        green += copy[k][l].rgbtGreen;
                        blue += copy[k][l].rgbtBlue;
                        pixel++;
                    }
                }
            }
            
            if (i - 1 >= 0 && j + 1 <= width)
            {
                red += copy[i - 1][j + 1].rgbtRed;
                green += copy[i - 1][j + 1].rgbtGreen;
                blue += copy[i - 1][j + 1].rgbtBlue;
                pixel++;
            }
            
            if (i + 1 <= height && j - 1 <= width)
            {
                red += copy[i + 1][j - 1].rgbtRed;
                green += copy[i + 1][j - 1].rgbtGreen;
                blue += copy[i + 1][j - 1].rgbtBlue;
                pixel++;
            }
            
            
        }
    }
    return;
}
